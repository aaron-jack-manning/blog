<html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width,initial-scale=1"><meta name="description" content="A blog (mostly) about things related to mathematics and computing."><meta name="author" content="Aaron Manning"><meta name="keywords" content="mathematics, math, maths, programming, education"><title>What I love about Rust</title><link rel="stylesheet" href="../../bootstrap/bootstrap.min.css"><link rel="stylesheet" href="../../stylesheet.css"><link rel="icon" type="image/png" href="../../images/favicon.png"><script type="text/javascript">window.MathJax = { tex: { inlineMath: [['$', '$'], ["\\(", "\\)"]], processEscapes: true, } }</script><script type="text/javascript" src="../../mathjax/es5/tex-chtml-full.js"></script></head><body style="font-family: &quot;Computer Modern&quot;, sans-serif;"><div class="container"><header class="py-3 pt-5" style="line-height: 1;border-bottom: 1px solid #e5e5e5;"><div class="row flex-nowrap justify-content-between align-items-center"><div class="col-12 text-center"><a class="text-dark" href="#" style="font-size: 2.25rem;">Aaron Manning's Blog</a></div></div></header><nav class="py-1 mb-2" style="border-bottom: 1px solid #e5e5e5;"><div class="row"><div class="p-2 col-md-3 text-center"><a href="../../">Featured</a></div><div class="p-2 col-md-3 text-center"><a href="../../all-posts">All Posts</a></div><div class="p-2 col-md-3 text-center"><a href="https://github.com/aaron-jack-manning/blog">Source</a></div><div class="p-2 col-md-3 text-center"><a href="../../rss/index.xml">RSS</a></div></div></nav></div><main class="container"><div class="row g-5"><div class="col-md-12"><article style="margin-bottom: 4rem;margin-top: 3rem;"><h2 style="margin-bottom: .25rem;font-size: 2.5rem;">What I love about Rust</h2><p style="font-size: 14pt;">Over the past few months I have been programming an increasing amount in the programming language Rust.</p><p style="font-size: 14pt;">Let's start with a little context. For quite a while now I have been looking for a general purpose programming language to invest a serious amount of my time and effort into as a long term technology. As such, it doesn't matter if the language doesn't have great libraries, or even a great standard library, as I can take the time implementing those things myself. I just need a good starting point of the fundamental language.</p><p style="font-size: 14pt;">This really started after I begin programming in F#, as the first functional programming language that I learned. At that point I realised how the tool I was using could make such a huge difference in my productivity as a programmer, and the process of learning F# really brought back for me the love of programming. F# has two major problems though: it is a VM language, running on .Net, and therefore doesn't produce standalone executables, and it's garbage collected, making it slow.</p><p style="font-size: 14pt;">At that point though, when I realised how a well designed language could make me love programming so much more, and allow me to work so much faster, I began the hunt for a programming language to solve the problems I had with F#. At this point though, I can say how much I deeply regret going on that journey. As Aditya Siram put it in a talk on ATS:</p><p style="font-size: 14pt;">"People keep saying that learning programming languages makes you a better programmer, it really doesn't. It makes you a better programmer up to a point, and then it makes you bitter and dissatisfied."</p><p style="font-size: 14pt;">This is exactly my experience. Choose a new language because of some interesting idea it has or some way it solves a problem with an existing technology, spend a long time programming in that language, realise it too has a bunch of compromises that are unacceptable, and then go hunting for another language.</p><p style="font-size: 14pt;">I tried everything from huge popular languages to small research languages.</p><p style="font-size: 14pt;">In general though, I had the following criteria:</p><ul><li><p style="font-size: 14pt;">Statically typed</p></li><li><p style="font-size: 14pt;">Deterministic and low cost memory management model (this rules out anything garbage collected)</p></li><li><p style="font-size: 14pt;">Produces a standalone executable, with no runtime</p></li><li><p style="font-size: 14pt;">No object oriented languages</p></li><li><p style="font-size: 14pt;">Complete support for generic types in a low cost way</p></li></ul><p style="font-size: 14pt;">So after trying many different options, and finding myself dissatisfied in one way or another with all of them, I eventually landed at Rust. My most recent attempt at learning Rust was not my  first. As I'm sure was true with many other people, I lost the fight against the borrow checker once and eventually came back.</p><p style="font-size: 14pt;">So why did I come back? I eventually reached the realisation that I would never find anything I was completely happy with, but if I wanted a programming language suitable for systems programming and needed some level of abstraction above C to make programming a faster, easier and more pleasant experience, then I'm left with C++ and Rust, and to be completely honest, it then just came down to the fact that Rust takes a more functional approach to programming, and many of C++s design decisions I find nonsensical.</p><p style="font-size: 14pt;">Rust has a lot of the things I love about functional programming languages, without the same costs in terms of performance that come with reference counting or garbage collection, or that purely functional data structures intrinsically give. Note though that I said 'a lot'. Not all. Making a distinction between functions and closures, and the way Rust handles closures, is something I find messy and confusing.</p><p style="font-size: 14pt;">But what makes Rust so great? Well here's my list.</p><hr><h3>Error Handling Approach</h3><p style="font-size: 14pt;">Exceptions are terrible. They make the control flow of your code needlessly complicated and difficult to read, with it possible for a function to not return as expected due to a deeply nested library being unhappy with certain input parameters. They also slow down your code needlessly and there's an unfortunate habit many developers get into of using exceptions to handle simple error cases and forcing library users to be exceptionally (no pun intended) careful when using any code they didn't write in production to verify it won't spontaneously halt. On the other hand, the mentality often taken in languages like C is to have a return value for errors which is not distinct in type from the success. This may mean returning -1 from a function which is always expected to return a positive number, to indicate an error state. This has the problem of conveying no meaningful information about the error and causing error cases to be hard to track logic errors rather than runtime errors.</p><p style="font-size: 14pt;">When I first started programming in F#, using Result type to handle all my errors, and computation expressions to do so very clearly and effortlessly, I wondered why there was no other language that went all is on this mentality and did away with exceptions entirely (which F# does not). It turns out there is: Rust!</p><p style="font-size: 14pt;">// examples</p><p style="font-size: 14pt;">Rust also has better support for handling the control flow issues that error states introduce than any other language I have used. They have the convenience of exceptions but are explicit.</p><p style="font-size: 14pt;">// example of ? operator</p><h3>Performance Predictability</h3><p style="font-size: 14pt;">Many people often credit Rust as being ridiculously fast, but low level languages aren't great because they're fast, it's because if they're slow it's clear why, and it's the fault of the programmer. On the flipside, lots of languages which run on a VM or are interpreted, can be slow because of things that aren't clear from the code, which make it significantly difficult to fix performance issues.</p><h3>You Can Do Anything in it</h3><p style="font-size: 14pt;">Rust is often pitched as a systems language, but the truth is, with things like the WASM backend to allow convenient web development in Rust, Rust is in many ways on track to be a language you can do whatever you want in. No one in their right mind would try and create an operating system in Javascript, just as you don't see front end web dev done in C. However, Rust is a technology that if you invest your time into it, it will pay off in more kinds of development than you can probably imagine.</p><h3>Developer Experience</h3><p style="font-size: 14pt;">Rust has by far the best tooling in terms of developer experience of any programming language I have used. I have spent less time fiddling with dependencies, less time finding obscure bugs and more time programming. To convey this fact, I am going to describe how to do some of the things that are inconvenient to do in other languages which are a breeze in Rust:</p><p style="font-size: 14pt;">// creating a binary project and running it// running code files with no project description format// cargo vendor// build script// crates io publish process// standardized documentation format with docs.rs</p><h3>Typeclasses!</h3><p style="font-size: 14pt;">//</p><h3>Statically Checked Duck Typing</h3><p style="font-size: 14pt;">For those who are unfamiliar with the world of dynamically typed languages and duck typing, first of all, I envy you, but secondly, there is one idea from dynamically typed programming languages that may be the only good thing to come from them: duck typing. The idea, is that if it walks like a duck and it quacks like a duck, then it must be a duck. More formally, if a bunch of types exhibit some characteristic, then it is okay to forget about the specific information of the concrete types, presuming you only use that characteristic when accessing instances of that type. This is all a bit abstract so let's look at an example:</p><p style="font-size: 14pt;">// JS example of putting a bunch of numbers into a collection even though they're distinct types and adding something to them later, before converting to a string</p><h3>(Only) The good parts of object oriented programming</h3><p style="font-size: 14pt;">One other area where Rust shines is the way it steals the best ideas from OOP and leaves the worst.</p><p style="font-size: 14pt;">When I call an instance method on a class in an object oriented language, it is often not immediately clear what that method will do to the underlying data. Does it just use it for calculation of the output? Does it modify the internal data? If it returns an instance of the same type is that the same, or a new pointer, and hence if I modify it will it change the underlying data?</p><p style="font-size: 14pt;">Rust solves this by making it very explicit what right a given function has to do with the type, by putting it in the type signature.</p><p style="font-size: 14pt;">// example of object oriented version which is very ambiguous, and rust example which is explicit</p><p style="font-size: 14pt;">As a consequence, calling methods with dot notation rather than writing a module level function is purely syntactic sugar.</p><p style="font-size: 14pt;">This allows the clean wrapping up of functionality with a type without creating all of the subtle and obscure code that object oriented languages do.</p><p style="font-size: 14pt;">One other way that it accomplishes this is with it's rules around exposure of functions to outside modules or crates. Rather than having a whole variety of different keywords (like internal, protected, etc) for levels of access, Rust chooses to have things private by default, public with the <code style="background-color: #eee;color: black;">pub</code> keyboard, and the option of exposing things to a specific level. For example, if I am writing a library and have a function that will be used pervasively throughout the library but I don't want users of the library to have access, I can use <code style="background-color: #eee;color: black;">pub (crate)</code>. This idea of choosing explicitly who can access what, solves the encapsulation problem OOP has be fighting with for decades so cleanly. In OOP you are stuck using inheritance as a way of exposing items to some bits of related code but not others.</p><p style="font-size: 14pt;">Rust also does away with this notion of types inheriting from types and abstracts shared behaviour into traits. This gives so many more options, allowing more complex relationships between the characteristics, without having types also adopt data from other types (just functionality).</p><h3>Dead Simple Concurrency Model</h3><p style="font-size: 14pt;">//</p><pre style="background-color: #eee;border-radius: 0.5em;display: block;padding: 1em;"><code style="">pub enum NodeValue {
    Document,
    FrontMatter(Vec<u8>),
    BlockQuote,
    List(NodeList),
    Item(NodeList),
    DescriptionList,
    DescriptionItem(NodeDescriptionItem),
    DescriptionTerm,
    DescriptionDetails,
    CodeBlock(NodeCodeBlock),
    HtmlBlock(NodeHtmlBlock),
    Paragraph,
    Heading(NodeHeading),
    ThematicBreak,
    FootnoteDefinition(Vec<u8>),
    Table(Vec<TableAlignment>),
    TableRow(bool),
    TableCell,
    Text(Vec<u8>),
    TaskItem(bool),
    SoftBreak,
    LineBreak,
    Code(NodeCode),
    HtmlInline(Vec<u8>),
    Emph,
    Strong,
    Strikethrough,
    Superscript,
    Link(NodeLink),
    Image(NodeLink),
    FootnoteReference(Vec<u8>),
}
</code></pre><h3>Macros</h3><p style="font-size: 14pt;">// example from html dsl</p><h3>Best of Functional Programming without Performance Cost</h3><p style="font-size: 14pt;">// Takes all the best ideas from functional programming but in a way that doesn't take a huge cost to performance. It's no secret that one of the best advantages of functional programming is that immutability makes your code safe, but Rust allows this. Instead it eliminates shared mutable state</p><hr><p style="font-size: 14pt;">Notice how in all of those things I mentioned I have yet to mention the borrow checker and Rust's guarantees about memory. This is because, in my opinion, the best thing about Rust is not it's guarantees about memory and concurrency.</p><p style="font-size: 14pt;">Rust is a fantastic language because it provides high level features whilst still compiling to fast, low level code, with no runtime. To me, arguments over whether the borrow checker is too restrictive or helps write better code are auxiliary.</p><p style="font-size: 14pt;">If you are also thinking about learning Rust, I would pass on this one piece of wisdom. Many people find Rust to be a difficult language to learn, especially if you come from a background in C++ where Rust is so similar yet different in confusing ways, and especially if you don't have any experience in functional languages such as OCaml. The main reason Rust can be a challenging language to learn though is not because any individual part of the language is hard to learn, but because it forces you to learn it all at once. I hope to have somewhat helped in resolving this problem by giving a bit of a tour of the language, but if you start programming in Rust with no other knowledge or context, it will immediately start forcing you to think about traits, macros, lifetimes, ownership, etc. So if you want to learn Rust, you have to be motivated by its design decisions and believe that upon becoming experienced they will help make you a better programmer, and you have to take your time to learn things slowly and deliberately, rather than rushing past new concepts as they arise.</p></article></div></div></main><footer style="padding: 2.5rem;color: #727272;text-align: center;background-color: #f9f9f9;border-top: .05rem solid #e5e5e5;"><p>By Aaron Manning</p><p><a href="#">Back to top</a></p></footer></body></html>